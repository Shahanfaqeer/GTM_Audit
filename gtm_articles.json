[
  {
    "url": "https://www.simoahava.com/analytics/variable-guide-google-tag-manager/",
    "content": "Variable Guide For Google Tag Manager\n(Updated 21 February 2019)\nThe current version of Google Tag Manager was released in October 2014. With the release, we saw a brand-spanking new UI, a lot of new functionalities (revamped auto-event tracking, for example), plus a new terminology to cope with. We moved away from the programming-centric concepts of Macros and Rules to the more tactile variables and triggers.\nIt’s difficult to rank the changes. The new Auto-Event Tracking is perhaps most impactful, but the improvements done to triggers and variables, when compared to the previous version of GTM, require attention as well.\nThus, I give you my variable Guide for Google Tag Manager. For reference, feel free to take a look at the old macro guide, since especially the different variable types have been left largely untouched.\nTable of Contents\nThe Simmer Newsletter\nSubscribe to the Simmer newsletter to get the latest news and content from Simo Ahava into your email inbox!\nIntroduction to Variables\nIn computing terms, variables denote compartments in computer memory, which are reserved for storing values. This is a significant achievement in efficiency, because it means that values can be reused across functions, procedures, and environments. The alternative would be to treat each representation of the same value as unique, temporary, and disposable, creating a mass of redundancy and inefficiency, and making the current computing landscape a whole lot different.\nIn Google Tag Manager, the term variable is used to denote a helper function that your tags, triggers, and other variables can invoke to retrieve values from. Thus, the idea is very similar to the broader concept of computing variables explored in the previous paragraph.\nIn GTM, invoking the variable function is done with a specific syntax:\n{{variable name}}\nAs we’ll learn later on, you can’t invoke variables wherever you’d want to. But in an approved context, the syntax {{variable name}} would run the underlying function of the variable with the name “variable name”, and pass the value returned by that function to its execution context (the tag, trigger, or variable where the syntax was used).\nOne of the first things all Google Tag Manager containers which run Google Analytics tags should do is this:\nHere, instead of always typing the tracking code for your web property (UA-XXXXXX-X) into each GA tag, you can create a Constant variable, which stores the value. Thus, whenever the variable name is invoked using the correct syntax, the tracking code returned by the Constant variable will be included in the appropriate tag field. This is something I’ve actually written a #GTMtips post about this.\nI will go so far as to say that variables can make or break GTM. When skeptics ask me what is the main benefit of having GTM on the site, I always end up talking about variables. They add a level of flexibility and customization that can really make your tagging lean, efficient, performance-driven, and time-saving.\nAt the same time, variables can be difficult to fathom, especially when we get to the technical details (see below), or when we try to tackle the amazingly multi-faceted and deviously difficult Custom JavaScript variable. I hope this guide will help you get to the bottom of variables, and encourage you to find your own ways of performing magic tricks with your GTM container.\nTechnical details and how-to\nFor you to be able to invoke a GTM variable, you need to be working in a script context, or the template field needs to support variable references.\nA supported template field can be uncovered by looking for the little variable symbol next to a field:\nAs you can see, the “Tag firing priority” field will not be able to invoke a variable, but the “Auto Link Domains” will. In fact, if you click the little variable icon, you will see a drop-down list from which you can pick the variable you want to use. This way you don’t have to worry about correct syntax, as GTM will do it for you.\nThe other places where you’ll frequently run into variables are:\n-\nTriggers\n-\nCustom HTML tags\n-\nCustom JavaScript variables\nWith triggers (remember to read my Trigger guide as well!), you will always need to specify a variable as the target of the trigger condition. Every single trigger condition needs a variable that is evaluated against some value. In fact, the condition builder is created so that you can’t possibly not choose a variable. It’s obligatory!\nNote that the value (right-hand) field of the trigger condition is NOT a variable context!\nAs for Custom HTML tags and Custom JavaScript variables, you can call variables from the scripts within, but you won’t have the helpful drop-down menu to assist you. You will need to manually type the call, using the correct syntax and the correct (case-sensitive) variable name:\n<!-- Sample Variable call in a Custom HTML Tag -->\n<script>\n(function() {\nalert({{custom alert string}});\n})();\n</script>\nThe code above will pop-up a browser alert, where the content will be the string returned by the variable named custom alert string. Note! If the variable doesn’t return a string, you might run into problems with the alert\nmethod, so you need to be well aware of return types and values at all times.\nIf you try to use a variable that doesn’t exist (or whose name you mistyped), you won’t be able to perform any operations on the container version (create, publish, etc.). You’ll run into an error message that looks like this:\nSo remember to check all the places where you’ve manually typed a variable call. It’s also possible that you’ve jumped the gun and called a variable, but then you forgot to create the variable itself. Retrace your steps and fix any broken links.\nOne cool thing that GTM does for you is this: when you change a variable name, all references to the variable are automatically updated. Even the ones you’ve typed in manually into Custom HTML tags and Custom JavaScript variables! This is incredibly time-saving, since you don’t have to go through every single reference, rewriting the code to match the new name.\nVariables are resolved according to the following process:\n-\nIf the variable is not attached to a trigger or a tag, the variable is never resolved (unless, of course, the variable is referenced from some other variable that is resolved).\n-\nIf the variable is referenced in a trigger that is not attached to any tags, the variable is never resolved.\n-\nIf the variable is referenced in a trigger that is attached to a tag, the variable is resolved every single time an\nevent\nkey is pushed intodataLayer\n. -\nIf the variable is referenced in a tag, the variable is resolved every single time the tag fires.\nThe last one is interesting. When a trigger causes a tag to “fire”, the process is actually this:\n-\nVariable calls are transformed into the actual function calls (\ngoogle_tag_manager['containerId'].macro('gtm10')\n) -\nThe tag code is injected on the site\n-\nThe tag code is executed, and all variable functions within are resolved\nAs you can see, a variable is actually a method of the google_tag_manager\nobject. The parameter that is given to the macro()\nmethod is basically ‘gtm’ plus a unique sequential number. This means that it’s very difficult to identify which macro()\nparameter is associated with which variable, which is why debugging has become an all-important tool in understanding how variables work.\nThe other, common case of variable resolution has to do with trigger conditions. When an ‘event’ key is pushed into dataLayer\n, every single trigger that is attached to a tag in your container is evaluated for the ‘event’ condition. In addition to checking the event\nvalue, all variables referenced in the trigger are evaluated, too.\nYou might want to re-read the previous paragraphs to grasp the idea, but this has very severe repercussions on how variables should (and should not be used):\nVariables must never have side effects\nRemember how variables should only be used to return values? Well, sometimes you might be tempted to use a variable to change the state of the global object or to set or push stuff into dataLayer\n. Don’t do it! Because variables can be resolved in multiple ways, and not just in tags as you’d expect, you might find yourself creating infinite loops, pushing stuff into dataLayer\nmultiple times, or severely hurting page performance.\nfunction() {\n// DON'T DO THIS:\nwindow.dataLayer.push({\n...\n});\n// OR THIS:\nalert(\"test\");\n// OR THIS:\nwindow.temp = getTempValue();\n// DO THIS:\nvar a = window.thisValue;\nvar b = getSomeOtherValue();\nreturn a + ': ' + b;\n}\nIf you’ve made it this far, congratulations. As a developer, I think it’s all-important to understand how variables work beyond the obvious, if only to realize the potential that variables have in improving the efficiency of your work with GTM.\nBuilt-in Variables\nThe new version of Google Tag Manager introduced Built-in variables. These are helpful, most commonly used variables, whose existence is based on binary logic: active / inactive. If the Built-in variable is activated, it can be used as any other variable, and if it’s not activated, it can’t.\nBuilt-in variables are thus no more than a shorthand for exploiting some of the most frequently used variable types in Google Tag Manager. I find it a bit odd that they’re not all activated by default, since there’s absolutely no harm in them being available for use.\nYou will find the Built-in variables displayed prominently in the top of the variables screen of your Google Tag Manager Container:\nIf the Built-in variable is listed here, it is active in the container. To add new Built-in variables, click the red CONFIGURE button, and check the box next to each variable you want to add to the container.\nAs with all variables, if the Built-in variable cannot be resolved (e.g. there was no Click action and you want to use Click ID), the variable returns the JavaScript undefined type.\nHere are the Built-in variables with a brief description of what they return:\nPages\n-\nPage URL - returns a string containing the full URL of the current page without hash fragment (\nhttps://www.simoahava.com/article?parameter=true\n) -\nPage Hostname - returns a string containing the the hostname of the current page (\nwww.simoahava.com\n) -\nPage Path - returns a string containing the relative path of the current page (\n/article\n) -\nReferrer - returns a string containing the URL of the page which brought the visitor to the current page (\nhttps://www.simoahava.com/home/\n), fromdocument.referrer\nUtilities\n-\nEvent - returns a string containing the value stored in the ‘event’\ndataLayer\nkey -\nEnvironment Name - returns the name of the environment currently being previewed (either via the Share Preview link or the environment’s container snippet)\n-\nContainer ID - returns a string containing the container ID (GTM-XXXXXX)\n-\nContainer Version - returns a string containing the current container version\n-\nRandom Number - returns a number, randomized between 0 and 2147483647\n-\nHTML ID - returns the identifier of the Custom HTML tag. Used with tag sequencing.\nErrors\n-\nError Message - returns a string containing the error message dispatched by a JavaScript Error trigger\n-\nError Line - returns a string containing the line number where the error was thrown\n-\nError URL - returns a string containing the URL of the script where the error was thrown\n-\nDebug Mode - returns a Boolean (true/false) depending on if the user is in GTM debug mode or not\nClicks\n-\nClick Element - returns an HTML element that was the target of an auto-event action; this object is retrieved from the\ngtm.element\nkey indataLayer\n-\nClick Classes - returns a string contained in the\nclassName\nattribute value of the auto-event element -\nClick ID - returns a string contained in the\nid\nattribute value of the auto-event element -\nClick Target - returns a string contained in the\ntarget\nattribute value of the auto-event element -\nClick URL - returns a string contained in the\nhref\noraction\nattribute value of the auto-event element -\nClick Text - returns a string contained in the\ntextContent / innerText\nattribute value of the auto-event element\nForms\nThese are exactly the same as the Click variables. I’m not sure why we need two sets of variables, when one generic “Auto-Event” type would suffice.\nHistory\n-\nNew History Fragment - returns a string containing the new URL fragment after a page history change auto-event action is registered\n-\nOld History Fragment - returns a string containing the previous URL fragment\n-\nNew History State - returns an object containing the new history state after a\npushState()\nhas been registered -\nOld History State - returns an object containing the old history state\n-\nHistory Source - returns a string describing the event that initiated the history change (e.g.\npopstate\norpushState\n)\nVideos\n-\nVideo Provider - returns a string containing the video service being tracked (currently YouTube only supported).\n-\nVideo Status - returns a string with the status of the video that caused the trigger to fire. Could be one of\n'start'\n,'pause'\n,'buffering'\n,'progress'\n, or'complete'\n. -\nVideo URL - returns a string with the URL of the embedded video.\n-\nVideo Title - returns a string with the title of the embedded video.\n-\nVideo Duration - returns a number with the total length of the video in seconds.\n-\nVideo Current Time - returns a number with the time mark where the user currently is (i.e. when the event was triggered).\n-\nVideo Percent - returns a number with the percentage mark where the user currently is.\n-\nVideo Visible - returns\ntrue\norfalse\n, depending on if the video was visible in the browser viewport when the event was triggered.\nScrolling\n-\nScroll Depth Threshold - returns a number with the value of the scroll tracking threshold that was crossed (e.g.\n25\nfor 25 percent or 25 pixels, depending on which the trigger is configured with). -\nScroll Depth Units - returns a string with\n'percent'\nor'pixels'\n, depending on which threshold type the trigger is tracking. -\nScroll Direction - returns a string with\n'vertical'\nor'horizontal'\n, depending on which direction is being tracked with the trigger.\nVisibility\n-\nPercent Visible - returns a number with the percentage of visibility for the element whose visibility is being tracked (e.g.\n50\nif half of the element is in the viewport). -\nOn-Screen Duration - returns a number with the total cumulative time (in milliseconds) that the element has been in the viewport when the trigger fires.\nAs you can see, the Built-in variables are just a quicker way to access some of the most common variable types. Read on, and check especially the chapter on variable types, as that will help you understand Built-in variables better as well.\nDebugging Variables\nIn the amazingly wonderful Debug Mode, there’s a tab for variables:\nBy clicking that tab, you can explore the state of each variable upon every single dataLayer\ninteraction. As you probably know, every single push to the dataLayer\nhas the potential to change the state of the data used by GTM, which is why you must be able to observe this state with every interaction. And this is what the variables section of the Debug pane enables you to do.\nFor example, here are two different states of dataLayer\n. The first state is when the Container snippet is first loaded, and the ‘event’ key is pushed with the value ‘gtm.js’:\nAs you can see, I’ve selected the “Page View” event in the left-hand-side navigation of the Debug pane. This corresponds to a dataLayer.push()\n, where the ‘event’ key was populated with ‘gtm.js’.\nNext, I select the “Window Loaded” event from the navigation. Here’s what the ‘event’ key looks like in this particular state:\nAs you can see, the value of the ‘event’ key has changed. So with the debug pane, you can explore the values stored in each variable at any given dataLayer\ninteraction.\nIf a variable has the value undefined, it means that the variable did not resolve. If you see this value in a state where you are certain the variable should have a proper value, it means there’s something wrong with your variables, tags, or triggers, and you need to look into it more carefully.\nBy clicking the Tags tab, you can examine what your variables returned in any tag that has fired (or not):\nYou can also look at tags which didn’t fire, and focus on the trigger. The visual display will tell you which variable condition did not pass the check, and you’ll know there’s something for you to debug again:\nThe Debug tool is incredibly useful, as it allows you to double-check how variables work in your current setup.\nVariable Types\nThere are a number of useful variable types for you to choose from, and you can use the Custom JavaScript variable to create custom variables of your own. Many of the variable types have some cool customization options as well, so you should take the time to study their many uses.\n1. HTTP Referrer\nUse the HTTP Referrer variable to identify details about the page that brought the visitor to the current one. The value is retrieved from the document.referrer\nproperty. Note: There is a Built-In variable for this (Referrer).\nRETURNS\nString with the URL of the referring page. You can specify a URL component if you wish (see the URL variable for more information about the various component types).\nUSE CASE(S)\nYou could create a trigger which fires when HTTP Referrer does not contain your own domain. This would mean that the user arrived from outside your site to the current page.\n2. URL\nThe URL variable can be used to access components of the current page URL (default) or of any URL string returned by a variable. This is a very versatile variable type, and is especially useful for traversing query parameters and hash fragments in your URLs. Note: There are Built-In variables for this (Page URL, Page Hostname, Page Path).\nThe Component Types you can choose are:\nFull URL - returns the full URL without the hash fragment, e.g. ‘https://www.simoahava.com/?home=true'.\nProtocol - returns the protocol of the URL, e.g. ‘https’.\nHost Name - returns the hostname of the URL without the port number, e.g. www.simoahava.com\n. You can choose to Strip ‘www.' to strip the ‘www’ subdomain from the hostname.\nPort - returns the port number used in the URL, or ‘80’ for HTTP / ‘443’ for HTTPS, if the URL has no port number.\nPath - returns only the pathname in the URL. You can also specify Default Pages to strip pages with names like ‘index.html’ or ‘index.php’ from the return string.\nQuery - returns the entire query parameter string (without leading ‘?'), if you don’t specify a query key. If you do specify a query key, only the value of this key is returned, or undefined if no such key is found in the URL.\nFragment - returns the value of the URL’s fragment without the leading ‘#’, e.g. ‘anchor1’.\nYou can expand the More Settings tab to find a source selector. In this selector, you can choose the variable whose return value the URL variable will access.\nRETURNS\nThe return value for the URL type you specified in the Component Type selection, or undefined if no such component is found in the URL variable. By default, the URL variable that is accessed is the page URL, but you can choose any variable which returns a string with a URL in it.\nUSE CASE(S)\nThis is, again, a very versatile variable. For example, check the following article for an example of how to use the URL variable to fix your site’s internal search tracking:\n3. First Party Cookie\nThe 1st Party Cookie variable returns the value for the first browser cookie with the name you specify in the Cookie Name field. For example, if you have a cookie called “session”, you can use the 1st Party Cookie variable to retrieve the value for this particular cookie.\nRETURNS\nString containing the value stored in the cookie, or undefined, if no such cookie exists.\nUSE CASE(S)\nI’ve used cookies a lot in my guides. Here are two examples for using cookies:\n4. Custom JavaScript\nThe Custom JavaScript variable is surely the most versatile variable in the set. You can use it to run arbitrary JavaScript on the page. It creates a script context, meaning you can also call other variables from within using the appropriate syntax.\nThe Custom JavaScript variable needs to follow two simple rules. First, the script must be wrapped in an anonymous function block (function() { ... }\n). Second, the function must have a return statement (return somevalue;\n).\nThe third, unwritten rule is that the function should only return a value. You shouldn’t use a Custom JavaScript variable to modify the global namescape by pushing values to dataLayer\nfor example. If you want to tamper with global variables from a function, it’s better to create a Custom HTML tag for this purpose.\nRETURNS\nDepends on what you have in the return\nstatement. You can return any variable or value, even other functions, other GTM variables, or nothing (a simple return;\nis the equivalent of returning the undefined value).\nUSE CASE(S)\nMany of my articles use the Custom JavaScript variable to some extent. Take a look at these to get started:\n5. Data Layer Variable\nThe Data Layer variable is extremely versatile as well. When you create a Data Layer variable, you specify the Data Layer key whose value you want to retrieve. When the variable is resolved, GTM will look for the most recent value for the key in the internal data model. For primitive values (Strings, numbers, Booleans, functions), the variable will return whatever was most recently pushed into the key. For plain objects and Arrays, the variable will return the result of a recursive merge, where only shared keys are replaced.\nYou can use dot notation to access both Data Layer variable keys which have a dot in their name (e.g. gtm.element\n), or to access properties of DOM element objects (e.g. gtm.element.dataset.name\n).\nYou can use dot notation to access Array members as well. Square notation won’t work, so replace the square notation with dots: products[0].name\nbecomes products.0.name\n.\nRETURNS\nThe value stored in the Data Layer variable whose name you point out in the Data Layer variable Name field. You can also retrieve the value of an object property, if you are sure that the variable holds an object. To access Array members, use dot notation instead of square notation. You can also specify a Default Value which will be returned if no variable with the given name can be found from the Data Layer when the variable is resolved. If you don’t give a default value, the Data Layer variable will return undefined in case no variable with the given name is found.\nUSE CASE(S)\nThe Data Layer variable is your best friend when you want to make the most of Auto-Event Tracking. The Built-In variables and the Auto-Event variable types only give you a handful of DOM properties to choose from in the auto-event element. Use the Data Layer variable to traverse the gtm.element\nobject as you wish.\nRemember to read my two earlier, in-depth articles about the Data Layer:\n6. JavaScript Variable\nThe JavaScript variable returns the value stored in the global JavaScript variable you specify. Note, this is NOT the same as the Custom JavaScript variable, which is a function declaration.\nRETURNS\nThe value stored in the global JavaScript variable that you specify. If no such global variable exists, the undefined value is returned instead.\nUSE CASE(S)\nHere’s an example of using the JavaScript variable with a custom tag. In this example, I show you how to fire a single tag multiple times by increasing a global JavaScript variable counter with each iteration, and then fetching the value of this variable in linked tags and variables.\n7. Undefined Value\nThe Undefined Value variable is extremely simple (so simple, in fact, that I’m wondering why it’s not a Built-in variable). Its sole purpose is to return the JavaScript undefined\nvalue. So it’s essentially the same as a Custom JavaScript variable with:\nfunction() {\nreturn;\n}\nRETURNS\nThe variable returns the undefined\nJavaScript value.\nUSE CASE(S)\nUse it whenever you might want to use the undefined\nvalue effectively. For example, you might want to use it in a Lookup Table or a RegEx Table, returning undefined\nwhen you want to ignore the value of the table in some cases (such as if you want to drop a Custom Dimension from a hit.\n8. Auto-Event Variable\nAuto-Event variables are used to access the target element of an auto-event action (e.g. Click, Error, Form Submit). When you create a new Auto-Event variable, you need to specify just which component of the target element you want to access.\nElement - Accesses the DOM Element itself that was the target of the auto-event action. This element is stored under the key gtm.element\nin the Data Layer, and you can create your own, customized auto-event variables using the Data Layer variable, and traversing the gtm.element\nobject as you would any other DOM element. For example, to get the value stored in the ID attribute of the auto-event element’s parent, you’d create a Data Layer variable which points to gtm.element.parentElement.id\n. Note: There are Built-In variables for this (Click Element and Form Element).\nElement Classes - Returns the value of the class\nattribute of the auto-event element. Stored in the Data Layer under the key gtm.elementClasses\n. Note: There are Built-In variables for this (Click Class and Form Class).\nElement ID - Returns the value of the id\nattribute of the auto-event element. Stored in the Data Layer under the key gtm.elementId\n. Note: There are Built-In variables for this (Click ID and Form ID).\nElement Target - Returns the value of the target\nattribute of the auto-event element. Stored in the Data Layer under the key gtm.elementTarget\n. Note: There are Built-In variables for this (Click Target and Form Target).\nElement Text - Returns the value of either the textContent\nor innerText\nproperty of the auto-event element. The return value is trimmed of whitespace and normalized to account for differences in how browsers interpret element text. Note: There are Built-In variables for this (Click Text and Form Text).\nElement URL - Returns the value of either the href\nor the action\nattribute of the auto-event element. You can further specify just which URL component you want to access (see the section for the URL variable type for more information). Stored in the Data Layer under the key gtm.elementUrl\n. Note: There are Built-In variables for this (Click URL and Form URL).\nHistory New URL Fragment - Returns the new URL fragment set with a browser history event. Stored in Data Layer under the key gtm.newUrlFragment. Note: There is a Built-In variable for this (New History Fragment).\nHistory Old URL Fragment - Returns the old URL fragment replaced in the browser history event. Stored in Data Layer under the key gtm.oldUrlFragment. Note: There is a Built-In variable for this (Old History Fragment).\nHistory New State - Returns the new state object set with a browser history event. Stored in Data Layer under the key gtm.newHistoryState. Note: There is a Built-In variable for this (New History State).\nHistory Old State - Returns the old state object replaced in the browser history event. Stored in Data Layer under the key gtm.oldHistoryState. Note: There is a Built-In variable for this (Old History State).\nHistory Change Source - Returns a string denoting the event that triggered the history change event (popstate, pushState, replaceState, or polling). Stored in Data Layer under the key gtm.historyChangeSource. Note: There is a Built-In variable for this (History Source).\nRETURNS\nThe Auto-Event variable returns the value appropriate for the selected element type. If no relevant auto-event has been registered, the variable returns the Default Value (if set), or undefined.\nUSE CASE(S)\nThere are many use cases for the Auto-Event variable. To get you started, I suggest you take a look at the following articles:\n9. DOM Element\nYou can use the DOM Element variable to retrieve the text content of any given DOM Element. You can also use it to retrieve the value of any attribute of the DOM Element.\nRETURNS\nThe text content of the given DOM Element, or the value of the given attribute (optional). If no DOM Element with the given ID or CSS selector is found, the variable returns the null value.\nUSE CASE(S)\nYou can use this to access any arbitrary DOM Element on the page. This becomes useful if you want to fire an event only if a certain element is on the page.\n10. Element Visibility\nThe Element Visibility variable lets you know if any particular element was visible in the browser viewport when the trigger fired. Visibility requires that the element be positioned above the fold of the page in the active browser tab. In other words, the element must actually be in sight of the user. The only exception is if there is some other window in front of the browser window where the element is otherwise visible. In this case, GTM would consider the element to still be visible, even though it’s not technically viewable by the user.\nRETURNS\nThe variable returns either True / False indicating if the element was visible or not, respectively, or a percentage of how much of the element was visible when the variable was resolved. You can choose which output type to use in the settings of the variable.\nUSE CASE(S)\nYou can set the visibility variable to check an element with CSS selector body\n, and minimum 1 percent visible. This variable would then tell you if the page was visible in the viewport when the variable was called.\n11. Constant\nThe Constant variable is a prime example of how variables are reusable. If you have any string of characters that you need to use often, or which you might need to update in the future, it’s best to store it as a Constant variable instead.\nRETURNS\nThe Constant variable returns the string you choose to type in the Value field.\nUSE CASE(S)\nThe obvious use case is your Google Analytics web property ID. By storing the UA-XXXXX-X code in the Constant variable, you won’t need to look it up every single time you create a new GA tag.\n12. Custom Event\nThe Custom Event variable returns the value of the ‘event’ key in the Data Layer. For example, if you run the following code: dataLayer.push({'event' : 'thisEvent'});\n, then the Custom Event variable would hold the value ‘thisEvent’ after the push. Note: There is a Built-In variable for this (Event).\nRETURNS\nThe value stored in the ‘event’ key in the Data Layer.\nUSE CASE(S)\nHonestly, I can’t figure out what this variable is for. If I had to guess, it’s a remnant of the old GTM, where you could accidentally delete the {{event}} macro and then use the Custom Event macro to bring it back. In the new UI, there’s a Built-In variable for Event, and at the time of writing there’s also the internal variable _event which you can’t delete or deactivate. So there really is no need to create a new Custom Event variable.\n13. Environment Name\nThe Environment Name variable is similar to Custom Event in that it doesn’t really add anything to GTM. There already is a Built-In variable for “Environment Name”, which you should use instead of creating this User-Defined variable.\nRETURNS\nString with the current environment name if using an environment snippet, or the draft version identifier if in Preview mode. It won’t return anything for Live or Latest versions.\nUSE CASE(S)\nUse it to fire tags only if in a certain environment. Remember to read my Environment Guide while you’re at it!\n14. Google Analytics Settings\nThe Google Analytics Settings variable returns a set of Universal Analytics tag settings. This can be used to configure multiple tags at once, consolidating their Custom Dimensions and Fields to set, for example.\nNote that the Google Analytics Settings variable can only be used in a Universal Analytics tag. You can’t invoke the variable in other contexts.\nRETURNS\nA configuration of Google Analytics Settings to be used in a Universal Analytics tag.\nUSE CASE(S)\nUse the Google Analytics Settings variable to consolidate tag settings across your Universal Analytics tags. For inspiration, read this article.\n15. Lookup Table\nThe Lookup Table variable performs any number of lookups that you specify, returning the value of the first match. Since this is a Lookup Table, the value lookup is always exact match and case-sensitive. You can create your own, custom Lookup Table if this is too strict for you.\nThe Input variable specifies the variable which will be used as the input in the lookups. On each row that you add to the table, you give an output value to be returned by the variable, if the input variable is matched with the Input field value of the row. You can chain Lookup Tables together, creating a powerful, efficient, and flexible value lookup for your tags and variables.\nRETURNS\nThe value in the Output field of the first row that is matched against the Input variable. You can also give a Default Value which will be returned if no match is made. If you don’t specify a Default Value, the variable will return the undefined value if no match is made.\nUSE CASE(S)\nTake a look at my original article for some ideas:\nBounteous has also a really interesting guide on automating the Lookup Table variable creation process.\n16. Random Number\nThe Random Number variable returns a random number between 0 and 2147483647. Note: There is a Built-In variable for this (Random Number).\nRETURNS\nA number, randomized between 0 and 2147483647.\nUSE CASE(S)\nYou can use the Random Number variable to sample your visitors.\n17. RegEx Table\nThe RegEx Table variable lets you create a pattern-matching table. It functions similarly to the Lookup Table, with the obvious difference that lookups are exact match only, whereas regular expressions are far more flexible in what you can match against. There are some other additional features in the RegEx Table, which you can read about here.\nRETURNS\nWhatever you have defined in each individual Output field, and the Default Value field.\nUSE CASE(S)\nYou can use the RegEx Table with a Just Links trigger to determine what type of link was clicked. See the screenshot above for hints how to do this.\n18. Container ID\nThis is also a Built-In variable, so use that instead of creating a new User-Defined variable.\nRETURNS\nThe public ID (GTM-XXXXXX) of the Container.\nUSE CASE(S)\nThis is important in tag sequencing, as it’s used to signal when a Custom HTML tag has finished completion. You should also send the Container ID as a Custom Dimension in your GTM hits - that way you can see in Google Analytics which hits were sent from which container.\n19. Container Version Number\nThis is pretty self-explanatory. The Container Version Number returns the version number of the container that is implemented on the site, or QUICK_PREVIEW if you are previewing the workspace draft. Note: There is a Built-In variable for this (Container Version).\nRETURNS\nString with the current GTM Container version number, or QUICK_PREVIEW, if the workspace draft is in preview mode.\nUSE CASE(S)\nAssign a Google Analytics Custom Dimension for the container version ID, which will help you analyze the impact of changes various versions of the GTM container have had. This is a great way to debug your GTM and GA implementations.\n20. Debug Mode\nThe Debug Mode variable returns true\nif the user is viewing the container in Preview mode, and false\nif not. Note: There is a Built-In variable for this (Debug Mode).\nRETURNS\ntrue when the user is in Container Debug mode, and false when not.\nUSE CASE(S)\nWith the Lookup Table variable, you can collect all your GA hits in Debug mode to a separate, test property. Read about this idea in my Macro Magic article.\nYou can also send the Debug Mode value as a Custom Dimension, if you want to collect all hits to the same GA property. This way you can filter with the Custom Dimension and collect all your debug hits to a separate Google Analytics profile.\nSummary\nI’m bold enough to claim that once you understand variables, you can call yourself a Google Tag Master. It’s not just what the different variable types are. It’s how you use them together to create sense out of the complexity that almost any tag implementation brings in its wake.\nJust remember to pay heed to the technical details as well. If you don’t understand the process of how variables are resolved, you’ll often run into unexpected situations. Most often it’s a ‘race condition’, where the variable is trying to access some other data source which isn’t ready yet.\nBe respectful of the ‘no side effects’ rule as well. Do not use variables for anything else except to build a well-formed return\nstatement. If you feel like you need to increase the complexity of your function calls, use a Custom HTML tag instead.\nWere you interested in some other aspect of variables that I didn’t cover here? Or do you have a great use case in mind for some variable type? Sound off in the comments, thanks!"
  },
  {
    "url": "https://www.simoahava.com/analytics/trigger-guide-google-tag-manager/",
    "content": "Trigger Guide For Google Tag Manager\nUpdated 27 March 2019\nIn the new version of Google Tag Manager, one of the most visible and profound changes to the previous version is how tags are fired (and blocked). First of all, there’s the obvious terminological distinction: we talk about triggers now, not rules. Second, triggers have become an integral part of the tag creation workflow, and as such have far more significance in the user interface than before.\nThe following text is a standalone article. It’s not an update to the guide I wrote for the previous GTM version: Google Tag Manager: Playing By The Rules, and many of the concepts covered therein are still valid.\nTriggers introduce many new features and functionalities (a new way of doing auto-event tracking, for example), which require special attention.\nHere are the contents of this guide:\nTable of Contents\nAs always, feel free to add your thoughts in the comments after this post, if there’s some aspect of triggers that wasn’t adequately covered.\nXThe Simmer Newsletter\nSubscribe to the Simmer newsletter to get the latest news and content from Simo Ahava into your email inbox!\n1. What’s changed\nThere are three major changes, in my opinion, to how triggers compare with the rules of the previous GTM version.\nI) Triggers are integrated into the workflow\nSure, this is more a cosmetic thing, but it’s significant. In the previous version of Google Tag Manager, the entry-level for beginners was quite high. This was partly due to the fact that it wasn’t clear just what firing rules and blocking rules do. It got even more confusing once you started learning about stuff like implicit events and conditions, and it didn’t help that the UI gave very little hints about what to do next.\nIn the new UI, everything is about the workflow. There’s actually a question there now: What triggers this tag to fire? Nothing about firing rules or blocking rules, nothing about event conditions, and so forth. Just the simple, quite self-explanatory question. Of course, to understand what “fire” means, you will need to do some exploration, but the question sets the scene: a tag needs a trigger to fire.\nSo the biggest obvious change is in the UI. Triggers are an integral part of the workflow, and it’s impossible to not notice them, as you may have with rules in the previous version.\nII) You don’t need to explicitly state the ‘event’ condition\nThe second major change is how you input the event condition. If you’ve read my previous posts about rules, or if you’ve paid attention to the developer guides, you’ll know that every single tag needs an ‘event’ push to fire. With ‘event’ push I’m of course referring to a dataLayer.push()\ncommand that gives a value to the key labelled ‘event’.\nThis time around, you don’t need to explicitly state the required Event condition (i.e. the value that ‘event’ key needs to have for the tag to fire). Instead, you rely on the available trigger types to set this condition up for you. In fact, the only time you have to explicitly state the name of the event is if you use a Custom Event type, and even then you don’t have to worry about setting it up as a proper condition. You just give the event its name in the required field (you can also use RegEx matching if you want more flexibility):\nThe point is that since Event is such a super-important part of any tag or trigger, it’s taken out of the normal condition-based setup for triggers and elevated to a grander status.\nIII) Auto-event tracking has changed\nI’ve already written a guide on this, and I’ll cover some of the concepts in this article as well, but this is really significant. Auto-event tracking is no longer tag-based, as it was in the previous version. Instead, you specify the event (click, link click, form submit, error, history event, or timer) by choosing one of the respective trigger types. Once you create a trigger for an auto-event type, GTM automatically starts listening for these events on your site.\nThis is incredibly convenient, since it reduces clutter in your tags, and it makes event tracking a very central part of any tagging setup (as it should be).\nThese are, in my view, the biggest changes. As a GTM fanboy, my honest and utterly biased opinion is that the improvements are amazing. There’s a learning curve, and I know that improvements are made to the UI constantly. But the way that triggers have been integrated into the tag workflow, without compromising any of the features carried over from rules, is a wonderful display of design skill.\n2. Technical overview\nIt’s not like I’ve reverse engineered the GTM container JavaScript library (well, not all of it), but there are some interesting things to consider when working with triggers.\nFirst of all, as I said above, triggers require a dataLayer.push()\nor a pre-container-snippet declaration to fire a tag. If a push()\ncommand doesn’t have an ‘event’ key, it becomes merely a “message” that’s added to the message bus. It does nothing for tags. You can see this in the debug mode. If there’s an ‘event’ key in the message, the instance gets the name of the event (unless it’s one of the three default GTM events, see below) or just “Message” if there’s no ‘event’ key in the command:\nSo if there’s an ‘event’ key in the push()\n, a data layer helper object activates and goes through all the active triggers in your container. If any one of these matches the value of the ‘event’ key, and if all the other conditions in the trigger pass, the tag is injected into the site and its code is executed.\nVery little has changed, then. You will still need to push ‘event’ values to fire tags. The three default events are still gtm.js (pushed when the container snippet is first rendered in the page template), gtm.dom (pushed when the DOM has loaded), and gtm.load (pushed when the window has loaded):\nOne thing that has changed is how multiple triggers of same type on the same page are handled.\nSince there’s no longer a listener tag that you work with, it’s more than possible that you can have many link click triggers, for example, activating tags on the same page. It doesn’t mean that GTM always attaches a new event listener to the document\nnode, because that would be an exercise in redundancy. Rather, all the triggers that use the same auto-event, e.g. gtm.linkClick\n, are evaluated when the event occurs.\nThis is fine in most cases, but it’s also possible that you have two Link Click triggers, where on one you have “Check Validation” set to ON, and on the other it’s OFF. This means that the first one only fires if the default action of the link click has not been prevented by other scripts, and the latter fires regardless. Since there’s just one listener controlling the firing of your tags, GTM leverages the gtm.triggers\nkey in the auto-event object to specify which trigger should fire upon the event:\nThe value of the key is containerID_triggerID. So in this particular example, I had two Link Click triggers firing on the page, and one of them had “Check Validation” ON. I then clicked a link where I had prevented the default action of the click with event.preventDefault()\n. Thus, the gtm.triggers\nkey tells our tags that only the trigger where “Check Validation” was OFF (id 27) is allowed to fire.\nThis makes for a very economical but still extremely robust setup for your auto-event triggers.\n3. Triggers in the workflow\nThere are two obvious paths to creating triggers: 1) through the tag workflow, and 2) via the Triggers menu.\nBoth paths take you essentially through the same steps.\nIn the tag workflow, you can enter the trigger selection screen in three different ways:\n-\nIf the tag has no triggers, then clicking the big empty space with “Choose a trigger to make this tag fire…” will open the trigger selector.\n-\nIf the tag already has triggers, then clicking the blue plus symbol lets you add new triggers to the tag.\n-\nYou can also click the ADD EXCEPTION link to add triggers that block the tag from firing.\nIn the trigger selection screen, clicking the blue plus button in the top right corner takes you to trigger creation mode.\nYou can also enter trigger creation mode by browsing to Triggers and clicking the red NEW button in the UI.\nRegardless of which path you take, this is what you’ll see:\nRead on for information how to create your new trigger.\n4. New trigger creation\nWhen you start creating a new trigger, you should already have a good idea of which GTM event should fire your tag.\nThe trigger type is essentially a combination of the GTM event and the type of interaction (or event) you want GTM to start listening to.\nHere are the trigger types currently available:\nPage View:\n-\nDOM Ready - fires the trigger on the\ngtm.dom\nevent, once the browser has loaded the document object model. -\nPage View - fires the trigger on the\ngtm.js\nevent, as soon as the GTM container has loaded. -\nWindow Loaded - fires the tirgger on the\ngtm.load\nevent, dispatched once the entire page and all linked resource have completed loading.\nClick:\n-\nAll Elements - fires the trigger on the\ngtm.click\nevent, dispatched when any element is clicked on the page. -\nJust Links - fires the trigger on the\ngtm.linkClick\nevent, dispatched when a link (<a>\n) HTML element is clicked on the page.\nUser Engagement:\n-\nElement Visibility - fires the trigger on the\ngtm.elementVisibility\nevent, when an element becomes visible on the page. -\nForm Submission - fires the trigger on the\ngtm.formSubmit\nevent, dispatched when a form submission is detected. -\nScroll Depth - fires the trigger on the\ngtm.scrollDepth\nevent, dispatched when the user scrolls the page. -\nYouTube Video - fires the trigger on the\ngtm.video\nevent, dispatched when a video is viewed on the page.\nOther:\n-\nCustom Event - fires the trigger when an\nevent\nkey is pushed intodataLayer\nwith a custom value. -\nHistory Change - fires the trigger on the\ngtm.historyChange\nevent, dispatched when a window history event is detected. -\nJavaScript Error - fires the trigger on the\ngtm.pageError\nevent, dispatched when an uncaught JavaScript error is thrown on the page. -\nTimer - fires the trigger on the\ngtm.timer\nevent, dispatched when the timer trigger interval is met. -\nTrigger Group - the trigger group fires when all the included triggers have fired at least once.\nThere’s bound to be more in the future. Especially the various events you can listen to with JavaScript are still vastly under-utilised (check this post for ideas how to extend them).\nThe next step is to choose any trigger-specific settings. With the DOM Ready trigger, for example, you can delimit the trigger to only fire on specific page URLs.\nIf you choose All (event type), the only condition in the trigger will be the event type. That means that your tag will fire every single time the event you specified is pushed into dataLayer\n. So if, for example, you chose a Click / All Elements trigger type, and you specify All Clicks as the filter, your tag will fire every single time a click is registered on the site (overkill much?).\nIf you choose Some (event type), you will need to specify the other condition(s) for your tag to fire. These can be anything you like, such as data layer variable values, page path matches, etc. As before, you can specify multiple conditions, but if you do, every single one of these conditions must pass for your tag to fire. There’s no either-or relationship here. Conditions are final.\nWith “Link Click”, “Timer” and “Form” triggers, you’ll see some extra settings in the Trigger, depending on what settings you choose. With “Timer”, you can set up the timer that will fire your tag after a given interval (or given intervals), and with Link Click and Form triggers, you might need to specify the conditions for the listener itself (see next chapter).\nAnd that’s it. If you’re in the tag creation workflow, you will now return to your tag, where you can add other triggers or an exception.\nIf you want to add multiple triggers to a single tag, do note that multiple triggers on the tag are in an either-or relationship. So having multiple triggers on a tag will make the tag fire when any of the triggers fire, which means that your tag can fire multiple times on a page unintentionally.\nHowever, if the underlying event on these multiple triggers is the same (e.g. Click), your tag will, by default, fire only once for every click event regardless of if there’s overlap in the triggers. You can change this behavior by opening the tag’s advanced settings:\nAdding exceptions is simple enough. Just click ADD EXCEPTION in the tag’s trigger selection, and choose a trigger which will block the firing of the tag.\nWith exceptions, blocking triggers will always win against firing triggers. However, blocking triggers always need a firing trigger with the same underlying event, otherwise they’re useless. This is because when an ‘event’ key is pushed into dataLayer\n, the blocking trigger can only block a trigger which fires on the same ‘event’, since they are evaluated at the same time against the same value of the ‘event’ key (complicated, I know!).\nRead more about it here: #GTMTips: Block Your Tags With Trigger Exceptions.\n5. Click and Form triggers\nSince I’ve already written about these in my latest auto-event tracking guide, I want to just briefly explain what makes these two triggers special.\nFirst of all, skip the generic Click / All Elemenets trigger. Nothing special about that. It just listens to all clicks on your site, regardless of what element you click.\nThe Just Links trigger, however, only listens for clicks which propagate up to a link (<a/>\n) node. This means that you can click on a SPAN in a BUTTON in a DIV, but as long as there’s a link wrapper somewhere up the ancestral tree, and as long as the event propagates, GTM will register the event as a link click.\nThe Form trigger waits for a submit()\nevent to be dispatched. This means that if some script on your site hijacks the form event and proceeds with some proprietary Ajax function, for example, GTM’s listener will not be able to pick it up.\nSo remember these two things: Just Links triggers require a click on a link, and Form triggers require a valid browser form submit event. Both need propagation to work.\nYou might have noticed the two clickable options on these two particular trigger types: Check Validation and Wait For Tags. Once you check either, you’ll see an extra step, Enable When, in the Trigger settings:\nThe point with this step is that you’ll be able to specify a condition for when the trigger is actively listening for the specified event. The most common condition types you’ll use here are page conditions, since you might want to specify that the Form Submit trigger only listens for submit events on pages with forms.\nThe reason this step was introduced is due to how the two checkable options, especially Wait For Tags, work. So let’s do a quick overview.\nCheck Validation, when checked, will require that a valid action is propagated to GTM’s listeners. With both Just Links and Form this means that there’s no event.preventDefault()\ncalled by other scripts on the event object before it reaches GTM’s handlers.\nHowever, in many cases it’s not just that the default action of the event is prevented, in which case GTM’s listeners will still pick up the event if Check Validation is OFF. Often you’ll see that propagation is stopped as well, which prevents GTM’s listeners from picking anything up. Be sure to see my previous two posts on the topic.\nWait For Tags ensures that all tags that fire on the trigger execute first before proceeding with the action of the event. So if it’s a Just Links trigger, the redirect (or whatever is the action) is programmatically halted long enough for all dependent tags to complete execution, after which the action is resumed. Same thing with forms.\nAnd this is the reason you need to specify the secondary filter. Since GTM is the one that halts the default action of the event, it’s possible that it screws something up in the propagation path. I’ve seen cases where the “Wait For Tags” option caused a pop-up blocker to pick up otherwise perfectly innocent lightboxes. Only by deactivating “Wait For Tags” was the problem solved.\nNOTE!!! The “Wait For Tags” can be very invasive on single-page apps, where link handling is completely customized. On single-page apps, an “internal” link should never lead to a redirect. GTM, however, does not know this. By pausing the event and then proceeding with the default action, it’s possible that “Wait For Tags” causes links to redirect when they shouldn’t.\nThus you should always be very careful with Wait For Tags and ONLY activate it on pages where you have THOROUGHLY tested it doesn’t interfere with the site’s default functionality.\n6. Triggers in the API\nSince I’ve such a huge fan of the GTM API (see my GTM Tools), I wanted to say a few quick words about triggers and the API.\nTriggers are a pollable resource just like anything else in the API. You can list them, retrieve them, update them, delete them, create them, etc.\nHowever, in their current state, there’s a complication. If you want to copy a tag from one container to another, the problem is the trigger ID. Each trigger has an ID, which, I think, is roughly the first available number in a sequence starting with 1. If you use a trigger in a tag, the tag will refer to this trigger using this ID.\nNow, when you want to copy this tag to another container, you create a new tag in the target container with this tag resource as the body. The problem is that the target container can already have a trigger with the ID, since they all follow the same logic when assigning the ID!\nThis means that when copying a tag with triggers to another container, what you actually need to do is this:\n-\nFirst create the trigger(s) in the new container\n-\nUse the object you receive in the response to see what the new trigger IDs are\n-\nUpdate the tag resource with the new trigger IDs\n-\nCreate the tag in the target container\nIt’s a pretty complex operation for something as simple as resource cloning, and I hope it will resolve to a simpler solution in the future.\nYou don’t have this problem with variables, as variables are referred to by name, not ID.\n7. Tag Sequencing\nOne important thing to know about triggers and tag sequencing is that if a tag is part of a tag sequence (either as a Setup or Cleanup tag), all its triggers are ignored.\nIn other words, tag sequencing trumps triggers. If a tag fires either before or after the main tag in a sequence, it will be completely controlled by the triggers of the main tag. The only way to prevent the tag from firing in a sequence is to pause it.\n8. Summary\nThat’s all I have to say about triggers, for now. I’m cautiously apprehensive about possible changes to the UI, as I’m sure there will be in the near future.\nTo sum it up, triggers work like a charm. It’s so important for usability to have them integrated into the workflow as they are now. At the same time, they haven’t lost any of their power, quite the contrary. The new, Trigger type -based approach to underlying events is an excellent addition, since it helps us focus on what’s important, instead of having to battle with confusing condition syntax.\nThere are things to be improved in the workflow. I don’t especially enjoy having to work through the Variables page to prepare my triggers (if the variables I need do not exist), and I think there’s still some unification of the UI called for, since, for example, the Some Pages view is so very different from all the other trigger choices.\nPlease sound off in the comments if I’ve missed something obvious. I would love to keep this guide as up to date as possible."
  }
]